#!/usr/bin/perl
package Pet::TestCase::WorkSheet;

#use Spreadsheet::ParseExcel;
use Data::Dumper;
use strict;

sub new {
	my($class, %args) = @_;
	my $self = {
		'CaseInfo' => {
			_case_desc => '',
			_case_generator => '',
			_case_version => '',
			_case_author => '',
			_case_date => '',
			_template_type => '',
			_template_version => '',
			_default_stepInterval => '',
		},
		'CaseList' => [],
	};	
	bless $self, $class;
	
	my($xlsFilename, $worksheetIndex);
	for(keys %args) {
		if(/-?xlsfile$/i) {
			$xlsFilename = delete $args{$_};
		}elsif(/-?worksheetindex/i) {
			$worksheetIndex = delete $args{$_};
		}
	}
	
	if (!defined($xlsFilename) or !defined($worksheetIndex))
	{
	   print ("usage: XLSFile, WorksheetIndex\n");
	   return undef;
	}
	my $parser   = Spreadsheet::ParseExcel->new();
	my $workbook = $parser->Parse( $xlsFilename );
	if ( !defined $workbook ) {
		print "Parsing error: ", $parser->error(), ".\n";
		return undef;
	}
	my @worksheets = $workbook->worksheets();
	unless ( exists $worksheets[$worksheetIndex]) {
		# print "$xlsFilename worksheet $worksheetIndex not exists .\n";
		return undef;
	}
	my $worksheet = $worksheets[$worksheetIndex];

    # print "Worksheet name: ", $worksheet->get_name(), "\n\n";

    my ( $startRow, $endRow ) = $worksheet->row_range();
    my ( $startCol, $endCol ) = $worksheet->col_range();

	# Test Case Descriptions:
	my $cell = $worksheet->get_cell( $startRow, $startCol ) or return undef;
	my @content = split(/\n/, $cell->value());
	chomp(@content);
	foreach(@content) {
		if(s/Test Case Description:\s*//i) {
			$self->{'CaseInfo'}->{'_case_desc'} = $_;
		}elsif(s/Generated by:\s*//i) {
			$self->{'CaseInfo'}->{'_case_generator'} = $_;
		}elsif(s/Version:\s*//i) {
			$self->{'CaseInfo'}->{'_case_version'} = $_;
		}elsif(s/Author:\s*//i) {
			$self->{'CaseInfo'}->{'_case_author'} = $_;
		}elsif(s/Date:\s*//i) {
			$self->{'CaseInfo'}->{'_case_date'} = $_;
		}
	}		
	# Test Case Template
	$cell = $worksheet->get_cell( $startRow, $startCol+3 );
	@content = split(/\n/, $cell->value());
	chomp(@content);
	foreach(@content) {
		if(s/Script Type:\s*//i) {
			$self->{'CaseInfo'}->{'_template_type'} = $_;
		}elsif(s/Version:\s*//i) {
			$self->{'CaseInfo'}->{'_template_version'} = $_;
		}
	}	
	
	$_ = $self->{'CaseInfo'}->{'_template_type'};
	if(/OSS TL1/) {
		$self->parse_OSS_TL1($worksheet);
	}else{
		print "Unsupported Sript Type: $_";
		return undef;
	}
	return $self;
}


sub dump_test_cases {
	my $self = shift;
	print Dumper($self);
	return $self;
}

# return 0 for success
# else return error msg
sub parse_OSS_TL1 {
	my $self = shift;
	my $worksheet = shift;
	my %Template_Color = (
		# (255,255,153)
		'FFFF99' => 'case_start', 
		# (204,255,204)
		'CCFFCC' => 'case_end', 
		# (255,255,255)
		'FFFFFF' => 'case_step', 
	);
    my ( $startRow, $endRow ) = $worksheet->row_range();
    my ( $startCol, $endCol ) = $worksheet->col_range();
	{
		my $cell = $worksheet->get_cell( $startRow+1, $startCol+4);
		die "Bad format" unless $cell;
		my $value = Translate($cell->value());
		$self->{'CaseInfo'}->{'_default_stepInterval'} = $1 if($value =~ /default[^\d]+(\d+)/);
	}
	my $current_case = {};
	my $case_valide = 1;
	for my $row ( $startRow+1 .. $endRow ) {
		my $cell = $worksheet->get_cell( $row, $startCol );
		next unless $cell;
		my $cell_color = Spreadsheet::ParseExcel->ColorIdxToRGB($cell->{'Format'}->{'Fill'}->[1]);

		# $cell_color =~ /(\w\w)(\w\w)(\w\w)/i;
		# print "[", $row+1, ", ", $startCol+1, "]\t = $cell_color (", join(",", hex($1), hex($2), hex($3)), ")\n";
			
		next unless exists $Template_Color{$cell_color};
		$_ = $Template_Color{$cell_color};
		if(/case_start/) {
			my %test_case = (
				'caseName' => $cell->value(),
				'stepNum' => 0,
			);
			if($test_case{caseName} =~ /^\s?#/) {
				$case_valide = 0;
			} else {
				$case_valide = 1;
				$current_case = \%test_case;
			}
		}elsif(/case_end/) {
			push @{$self->{'CaseList'}}, $current_case if $case_valide;
			$current_case = {};
		}elsif(/case_step/){
			return "Unexpected test steps" unless $current_case;
			next unless $case_valide;
			my $step_valide = 1;
			my @step_command;
			for my $col ($startCol .. $startCol+3 ) {
				my $cell = $worksheet->get_cell( $row, $col );
				if(!$cell) {
					print STDERR "Cell (", $row+1, ", ", $col+1, ") should not be empty";
					return "Exception failure";
				}
				if($cell->value() =~ /^\s?#/) {
					$step_valide = 0;
					last;
				}
				my $value = Translate($cell->value());
				$value =~ s/^\s+//;
				$value =~ s/(\s|\n)+$//;
				push @step_command, $value;
			}
			next unless $step_valide;
			my $stepInterval = $self->{'CaseInfo'}->{'_default_stepInterval'};
			if(my $cell = $worksheet->get_cell( $row, $startCol+4)) {
				my $value = Translate($cell->value());
				$value =~ s/^\s+//;
				$value =~ s/[^\d]+$//;
				$stepInterval = $value if $value;
			}
			push @step_command, $stepInterval;
			$current_case->{'stepNum'}++;
			my $stepKey = 'Step'.($current_case->{'stepNum'});	
			$current_case->{$stepKey} = \@step_command;
		}
    }
	return 0;	
}

sub Translate {
	my $value          = shift;
	return undef unless defined $value;
	return $value unless ( $value =~ /\$/ );
	my @sections = split( /\$/, $value );
	my $resultValue = $sections[0];
	for ( my $i = 1 ; $i < scalar(@sections) ; $i++ ) {
		my $const_part = $sections[$i];
		$const_part =~ s/^[[:word:]]+//;
		my $var_part = $sections[$i];
		$var_part =~ s/\Q$const_part\E$//;
		# print $sections[$i], " is divided into: ", $var_part, " and ", $const_part, "\n";
		no strict 'refs';
		if ( defined ${"main::$var_part"} ) {
			$resultValue .= ${"main::$var_part"} . $const_part;
		}
		else {
			if($value =~ /\$\Q$var_part\E/) {
				print STDERR "Undefined parameter \$$var_part in command \"$value\".\n";
			}
			$resultValue .= $sections[$i];
		}
	}

	# print "\nbefore:\t", $value, "\nafter:\t", $resultValue, "\n\n";
	return $resultValue;
}

1;
